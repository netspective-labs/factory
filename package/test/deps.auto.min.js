class EventEmitter{_events_=new Map;on(event,listener){return this._events_.has(event)||this._events_.set(event,new Set),this._events_.get(event).add(listener),this}once(event,listener){const l=listener;return l.__once__=!0,this.on(event,l)}off(event,listener){if(null==event&&listener)throw new Error("Why is there a listenerÂ defined here?");if(null!=event||listener){if(event&&!listener)this._events_.delete(event);else if(event&&listener&&this._events_.has(event)){const _=this._events_.get(event);_.delete(listener),0===_.size&&this._events_.delete(event)}}else this._events_.clear();return this}emitSync(event,...args){if(!this._events_.has(event))return this;const _=this._events_.get(event);for(let[,listener]of _.entries()){const r=listener(...args);r instanceof Promise&&r.catch(console.error),listener.__once__&&(delete listener.__once__,_.delete(listener))}return 0===_.size&&this._events_.delete(event),this}async emit(event,...args){if(!this._events_.has(event))return this;const _=this._events_.get(event);for(let[,listener]of _.entries())try{await listener(...args),listener.__once__&&(delete listener.__once__,_.delete(listener))}catch(error){console.error(error)}return 0===_.size&&this._events_.delete(event),this}queue(event,...args){return(async()=>await this.emit(event,...args))().catch(console.error),this}pull(event,timeout){return new Promise((async(resolve,reject)=>{let timeoutId,listener=(...args)=>{null!==timeoutId&&clearTimeout(timeoutId),resolve(args)};timeoutId="number"!=typeof timeout?null:setTimeout((()=>(this.off(event,listener),reject(new Error("Timed out!"))))),this.once(event,listener)}))}clone(cloneListeners=!0){const emitter=new EventEmitter;if(cloneListeners)for(const[key,set]of this._events_)emitter._events_.set(key,new Set([...set]));return emitter}}export{EventEmitter};function humanFriendlyBytes(bytes,si=!1,dp=1){const thresh=si?1e3:1024;if(Math.abs(bytes)<thresh)return bytes+" B";const units=si?["kB","MB","GB","TB","PB","EB","ZB","YB"]:["KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"];let u=-1;const r=10**dp;do{bytes/=thresh,++u}while(Math.round(Math.abs(bytes)*r)/r>=thresh&&u<units.length-1);return bytes.toFixed(dp)+" "+units[u]}function humanFriendlyPhrase(text){return text.replace(/[^a-zA-Z0-9 ]/g," ").replace(/\s\s+/g," ").replace(/(^\w{1})|(\s+\w{1})/g,(letter=>letter.toUpperCase()))}const humanPath=(original,maxLength=50,formatBasename)=>{const tokens=original.split("/"),basename=tokens[tokens.length-1];if(tokens.splice(0,1),tokens.splice(tokens.length-1,1),original.length<maxLength)return(tokens.length>0?tokens.join("/")+"/":"")+(formatBasename?formatBasename(basename):basename);const remLen=maxLength-basename.length-4;if(remLen>0){const path=tokens.join("/"),lenA=Math.ceil(remLen/2),lenB=Math.floor(remLen/2);return path.substring(0,lenA)+"..."+path.substring(path.length-lenB)+"/"+(formatBasename?formatBasename(basename):basename)}return formatBasename?formatBasename(basename):basename};export{humanFriendlyBytes};export{humanFriendlyPhrase};export{humanPath};function minWhitespaceIndent(text){const match=text.match(/^[ \t]*(?=\S)/gm);return match?match.reduce(((r,a)=>Math.min(r,a.length)),1/0):0}function unindentWhitespace(text,removeInitialNewLine=!0){const indent=minWhitespaceIndent(text),regex=new RegExp(`^[ \\t]{${indent}}`,"gm"),result=text.replace(regex,"");return removeInitialNewLine?result.replace(/^\n/,""):result}function singleLineTrim(text){return text.replace(/(\r\n|\n|\r)/gm,"").replace(/\s+(?=(?:[^\'"]*[\'"][^\'"]*[\'"])*[^\'"]*$)/g," ").trim()}function whitespaceSensitiveTemplateLiteralSupplier(literals,suppliedExprs,options){const{unindent:unindent=!0,removeInitialNewLine:removeInitialNewLine=!0}=options??{};let literalSupplier=index=>literals[index];if(unindent)if("boolean"==typeof unindent){let originalText="";for(let i=0;i<suppliedExprs.length;i++)originalText+=literals[i]+`\${expr${i}}`;originalText+=literals[literals.length-1];const match=originalText.match(/^[ \t]*(?=\S)/gm),minWhitespaceIndent=match?match.reduce(((r,a)=>Math.min(r,a.length)),1/0):0;if(minWhitespaceIndent>0){const unindentRegExp=new RegExp(`^[ \\t]{${minWhitespaceIndent}}`,"gm");literalSupplier=index=>{let text=literals[index];return 0==index&&removeInitialNewLine&&(text=text.replace(/^\n/,"")),text.replace(unindentRegExp,"")}}}else literalSupplier=index=>{let text=literals[index];return 0==index&&removeInitialNewLine&&(text=text.replace(/^\n/,"")),text.replace(unindent,"")};return literalSupplier}export{minWhitespaceIndent};export{unindentWhitespace};export{singleLineTrim};export{whitespaceSensitiveTemplateLiteralSupplier};const jsTokenEvalRE=/^[a-zA-Z0-9_]+$/;function jsTokenEvalResult(identity,discover,isTokenValid,onInvalidToken,onFailedDiscovery){let result;if(identity.match(jsTokenEvalRE))try{if(Array.isArray(discover)){for(const te of discover)if(result=te(identity),result)break}else result=discover(identity);result&&isTokenValid&&(result=isTokenValid(result,identity))}catch(error){result=onFailedDiscovery?.(error,identity)}else result=onInvalidToken?.(identity);return result}const jsTokenEvalResults={};function cacheableJsTokenEvalResult(name,discover=eval,onInvalidToken,onFailedDiscovery){return name in jsTokenEvalResults?jsTokenEvalResults[name]:jsTokenEvalResult(name,discover,((value,name)=>(jsTokenEvalResults[name]=value,value)),onInvalidToken,onFailedDiscovery)}function*walkHooks(targets,hookNameSuppliers,discover,prepareWalkEntry){const suppliers=Array.isArray(hookNameSuppliers)?hookNameSuppliers:[hookNameSuppliers];for(const target of targets)for(const hookNameSupplier of suppliers){const hookName=hookNameSupplier(target);if(hookName){const hookDiscovered=jsTokenEvalResult(hookName,discover,(value=>value),(name=>{console.log(`[discoverDomElemHook] '${name}' is not a token in current scope for`,target)}));let hookExecArgs={target:target,hookDiscovered:hookDiscovered,hookName:hookName,hookNameSupplier:hookNameSupplier};if(prepareWalkEntry){const prepared=prepareWalkEntry(hookExecArgs);if(!prepared)continue;hookExecArgs=prepared}const hookExecResult=hookDiscovered&&"function"==typeof hookDiscovered?hookDiscovered(hookExecArgs):void 0;yield hookExecResult??hookExecArgs}}}function flexibleArgs(argsSupplier,rulesSupplier){const rules=rulesSupplier?"function"==typeof rulesSupplier?rulesSupplier(argsSupplier):rulesSupplier:void 0,defaultArgsSupplier=rules?.defaultArgs??{},defaultArgs="function"==typeof defaultArgsSupplier?defaultArgsSupplier(argsSupplier,rules):defaultArgsSupplier;let args="function"==typeof argsSupplier?argsSupplier(defaultArgs,rules):argsSupplier?{...defaultArgs,...argsSupplier}:defaultArgs;rules?.argsGuard&&(rules?.argsGuard.guard(args)||(args=rules.argsGuard.onFailure(args,rules)));let result={args:args,rules:rules};return rules?.finalizeResult&&(result=rules.finalizeResult(result)),result}function governedArgs(argsSupplier,rulesSupplier){return flexibleArgs(argsSupplier,rulesSupplier)}export{jsTokenEvalResult};export{cacheableJsTokenEvalResult};export{walkHooks};export{flexibleArgs};export{governedArgs};const posixPathRE=/^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;function detectFileSysStyleRoute(text){const components=posixPathRE.exec(text)?.slice(1);if(!components||5!==components.length)return;const modifiers=[],parsedPath={root:components[1],dir:components[0].slice(0,-1),base:components[2],ext:components[4],name:components[3],modifiers:modifiers},modifierIndex=parsedPath.name.lastIndexOf(".");if(modifierIndex>0){let ppn=parsedPath.name,modifier=ppn.substring(modifierIndex);for(;modifier&&modifier.length>0;){modifiers.push(modifier),ppn=ppn.substring(0,ppn.length-modifier.length);const modifierIndex1=ppn.lastIndexOf(".");modifier=modifierIndex1>0?ppn.substring(modifierIndex1):void 0}parsedPath.name=ppn}return parsedPath}export{detectFileSysStyleRoute};function typeGuard(...requireKeysInSingleT){return o=>!(!o||"object"!=typeof o)&&!requireKeysInSingleT.find((p=>!(p in o)))}const isIdentifiablePayload=typeGuard("payloadIdentity"),ValidatedPayload=typeGuard("isValidatedPayload","isValidPayload");function isEventSourceService(o){return typeGuard("isEventSourcePayload","prepareEventSourcePayload")(o)}function isFetchService(o){return typeGuard("fetch","prepareFetchContext","prepareFetchPayload","prepareFetch","prepareFetchResponsePayload")(o)}function isWebSocketSendService(o){return typeGuard("webSocketSend","prepareWebSocketSendPayload","prepareWebSocketSend")(o)}function isWebSocketReceiveService(o){return typeGuard("isWebSocketReceivePayload","prepareWebSocketReceivePayload")(o)}export{isIdentifiablePayload};export{ValidatedPayload};export{isEventSourceService};export{isFetchService};export{isWebSocketSendService};export{isWebSocketReceiveService};function typicalConnectionValidator(pingURL){return{validationEndpointURL:pingURL,validate:()=>fetch(pingURL,{method:"HEAD"})}}var ReconnectionState;!function(ReconnectionState){ReconnectionState.IDLE="idle",ReconnectionState.TRYING="trying",ReconnectionState.COMPLETED="completed",ReconnectionState.ABORTED="aborted"}(ReconnectionState||(ReconnectionState={}));class ReconnectionStrategy{maxAttempts;intervalMillecs;onStateChange;#state=ReconnectionState.IDLE;#attempt=0;constructor(options){this.maxAttempts=options?.maxAttempts??15,this.intervalMillecs=options?.intervalMillecs??1e3,this.onStateChange=options?.onStateChange}get isTrying(){return this.#state==ReconnectionState.TRYING}get isAborted(){return this.#state==ReconnectionState.ABORTED}get attempt(){return this.#attempt}get state(){return this.#state}set state(value){const previousStatus=this.#state;this.#state=value,this.onStateChange?.(this.#state,previousStatus,this)}reconnect(){return this.#attempt++,this.#attempt>this.maxAttempts?this.completed(ReconnectionState.ABORTED):this.state=ReconnectionState.TRYING,this}completed(status=ReconnectionState.COMPLETED){return this.state=status,this}}export{typicalConnectionValidator};export{ReconnectionState};export{ReconnectionStrategy};const isEventSourceConnectionHealthy=typeGuard("isHealthy","connEstablishedOn"),isEventSourceConnectionUnhealthy=typeGuard("isHealthy","connFailedOn"),isEventSourceReconnecting=typeGuard("isHealthy","connFailedOn","reconnectStrategy"),isEventSourceError=typeGuard("isEventSourceError","errorEvent"),isEventSourceEndpointUnavailable=typeGuard("isEndpointUnavailable","endpointURL");class EventSourceTunnel{esURL;esEndpointValidator;observerUniversalScopeID="universal";eventSourceFactory;onConnStateChange;onReconnStateChange;#connectionState={isConnectionState:!0};#reconnStrategy;constructor(init){this.esURL=init.esURL,this.esEndpointValidator=init.esEndpointValidator,this.eventSourceFactory=init.eventSourceFactory,this.onConnStateChange=init.options?.onConnStateChange,this.onReconnStateChange=init.options?.onReconnStateChange}isReconnecting(){return!!this.#reconnStrategy&&this.#reconnStrategy}isReconnectAborted(){return!(!this.#reconnStrategy||!this.#reconnStrategy.isAborted)}connected(es,connState){this.#reconnStrategy&&this.#reconnStrategy.completed(),this.eventSourceFactory.connected?.(es),this.connectionState=connState,this.#reconnStrategy=void 0}prepareReconnect(connState){return this.#reconnStrategy=this.#reconnStrategy??new ReconnectionStrategy({onStateChange:this.onReconnStateChange?(active,previous,rs)=>{this.onReconnStateChange?.(active,previous,rs,this)}:void 0}),connState={...connState,reconnectStrategy:this.#reconnStrategy},this.connectionState=connState,this.#reconnStrategy.reconnect()}init(){if(!this.isReconnectAborted())return this.esEndpointValidator.validate(this.#reconnStrategy).then((resp=>{if(resp.ok){const eventSource=this.eventSourceFactory.construct(this.esURL),coercedES=eventSource;coercedES.onopen=()=>{this.connected(eventSource,{isConnectionState:!0,isHealthy:!0,connEstablishedOn:new Date,endpointURL:this.esURL,pingURL:this.esEndpointValidator.validationEndpointURL.toString()})},coercedES.onerror=event=>{coercedES.close();const connState={isConnectionState:!0,isHealthy:!1,connFailedOn:new Date,isEventSourceError:!0,errorEvent:event},reconnectStrategy=this.prepareReconnect(connState);setTimeout((()=>this.init()),reconnectStrategy.intervalMillecs)}}else{const connState={isConnectionState:!0,isHealthy:!1,connFailedOn:new Date,isEndpointUnavailable:!0,endpointURL:this.esURL,pingURL:this.esEndpointValidator.validationEndpointURL.toString(),httpStatus:resp.status,httpStatusText:resp.statusText},reconnectStrategy=this.prepareReconnect(connState);setTimeout((()=>this.init()),reconnectStrategy.intervalMillecs)}})).catch((connectionError=>{const connState={isConnectionState:!0,isHealthy:!1,connFailedOn:new Date,pingURL:this.esEndpointValidator.validationEndpointURL.toString(),connectionError:connectionError,isEndpointUnavailable:!0,endpointURL:this.esURL},reconnectStrategy=this.prepareReconnect(connState);setTimeout((()=>this.init()),reconnectStrategy.intervalMillecs)})),this}get connectionState(){return this.#connectionState}set connectionState(value){const previousConnState=this.#connectionState;this.#connectionState=value,this.onConnStateChange?.(this.#connectionState,previousConnState,this)}}function eventSourceConnNarrative(tunnel){const sseState=tunnel.connectionState,reconn=tunnel.isReconnecting();let reconnected=!1;if(reconn)switch(reconn.state){case ReconnectionState.TRYING:return{summary:`reconnecting ${reconn.attempt}/${reconn.maxAttempts}`,color:"orange",isHealthy:!1,summaryHint:`Trying to reconnect to ${tunnel.esURL} (ES), reconnecting every ${reconn.intervalMillecs} milliseconds`};case ReconnectionState.ABORTED:return{summary:"ABORTED",color:"red",isHealthy:!1,summaryHint:`Unable to reconnect to ${tunnel.esURL} (ES) after ${reconn.maxAttempts} attempts, giving up`};case ReconnectionState.COMPLETED:reconnected=!0}if(isEventSourceConnectionHealthy(sseState))return{summary:reconnected?"reconnected":"connected",color:"green",isHealthy:!0,summaryHint:`Connection to ${sseState.endpointURL} (ES) verified using ${sseState.pingURL} on ${sseState.connEstablishedOn}`};let summary="unknown",color="purple",summaryHint="the EventSource tunnel is not healthy, but not sure why";return isEventSourceConnectionUnhealthy(sseState)&&(isEventSourceEndpointUnavailable(sseState)?(summary="ES unavailable",summaryHint=`${sseState.endpointURL} (ES) not available`,sseState.httpStatus&&(summary=`ES unavailable (${sseState.httpStatus})`,summaryHint+=` (HTTP status: ${sseState.httpStatus}, ${sseState.httpStatusText})`,color="red")):isEventSourceError(sseState)&&(summary="error",summaryHint=JSON.stringify(sseState.errorEvent),color="red")),{isHealthy:!1,summary:summary,summaryHint:summaryHint,color:color}}export{isEventSourceConnectionHealthy};export{isEventSourceConnectionUnhealthy};export{isEventSourceReconnecting};export{isEventSourceError};export{isEventSourceEndpointUnavailable};export{EventSourceTunnel};export{eventSourceConnNarrative};function serviceBusArguments(options){return{eventNameStrategy:{universalScopeID:"universal",fetch:payload=>{const identity="string"==typeof payload?payload:payload.payloadIdentity,payloadSpecificName=`fetch-${identity}`;return{payloadSpecificName:payloadSpecificName,universalName:"fetch",selectedName:"universal"==identity?"fetch":payloadSpecificName}},fetchResponse:payload=>{const identity="string"==typeof payload?payload:payload.payloadIdentity,payloadSpecificName=`fetch-response-${identity}`;return{payloadSpecificName:payloadSpecificName,universalName:"fetch-response",selectedName:"universal"==identity?"fetch-response":payloadSpecificName}},fetchError:payload=>{const identity="string"==typeof payload?payload:payload.payloadIdentity,payloadSpecificName=`fetch-error-${identity}`;return{payloadSpecificName:payloadSpecificName,universalName:"fetch-error",selectedName:"universal"==identity?"fetch-error":payloadSpecificName}},eventSource:payload=>{const identity="string"==typeof payload?payload:payload.payloadIdentity,payloadSpecificName=`event-source-${identity}`;return{payloadSpecificName:payloadSpecificName,universalName:"event-source",selectedName:"universal"==identity?"event-source":payloadSpecificName}},eventSourceError:payload=>{const identity="string"==typeof payload?payload:payload.payloadIdentity,payloadSpecificName=`event-source-error-${identity}`;return{payloadSpecificName:payloadSpecificName,universalName:"event-source-error",selectedName:"universal"==identity?"event-source-error":payloadSpecificName}},eventSourceInvalidPayload:()=>({payloadSpecificName:void 0,universalName:"event-source-invalid-payload",selectedName:"event-source-invalid-payload"}),webSocket:payload=>{const identity="string"==typeof payload?payload:payload.payloadIdentity,payloadSpecificName=`web-socket-${identity}`;return{payloadSpecificName:payloadSpecificName,universalName:"web-socket",selectedName:"universal"==identity?"web-socket":payloadSpecificName}},webSocketError:payload=>{const identity="string"==typeof payload?payload:payload.payloadIdentity,payloadSpecificName=`web-socket-error-${identity}`;return{payloadSpecificName:payloadSpecificName,universalName:"web-socket-error",selectedName:"universal"==identity?"web-socket-error":payloadSpecificName}},webSocketInvalidPayload:()=>({payloadSpecificName:void 0,universalName:"web-socket-invalid-payload",selectedName:"web-socket-invalid-payload"})},...options}}class ServiceBus extends EventTarget{esTunnels;wsTunnels;eventListenersLog;constructor(args){super(),this.args=args,this.esTunnels=[],this.wsTunnels=[],this.eventListenersLog=[],args.esTunnels&&this.registerEventSourceTunnels(args.esTunnels),args.wsTunnels&&this.registerWebSocketTunnels(args.wsTunnels)}registerEventSourceTunnels(ests){for(const tunnel of ests((event=>{const eventSrcPayload=JSON.parse(event.data),esDetail={event:event,eventSrcPayload:eventSrcPayload};this.dispatchNamingStrategyEvent(eventSrcPayload,isIdentifiablePayload(eventSrcPayload)?this.args.eventNameStrategy.eventSource:this.args.eventNameStrategy.eventSourceInvalidPayload,esDetail)})))this.esTunnels.push(tunnel)}registerWebSocketTunnels(ests){for(const tunnel of ests((event=>{if("string"==typeof event.data){const payload=JSON.parse(event.data),wsDetail={event:event,payload:payload,webSocketStrategy:this};this.dispatchNamingStrategyEvent(payload,isIdentifiablePayload(payload)?this.args.eventNameStrategy.webSocket:this.args.eventNameStrategy.webSocketInvalidPayload,wsDetail)}else{const payload1=event.data;if(isIdentifiablePayload(payload1)){const wsDetail1={event:event,payload:payload1,webSocketStrategy:this};this.dispatchNamingStrategyEvent(payload1,this.args.eventNameStrategy.webSocket,wsDetail1)}else this.dispatchNamingStrategyEvent(event.data,this.args.eventNameStrategy.webSocketInvalidPayload,{event:event,webSocketStrategy:this})}})))this.wsTunnels.push(tunnel)}dispatchNamingStrategyEvent(id,strategy,detail){const names=strategy(id);names.payloadSpecificName&&this.dispatchEvent(new CustomEvent(names.payloadSpecificName,{detail:detail})),this.dispatchEvent(new CustomEvent(names.universalName,{detail:detail}))}addEventListener(type,listener,options){super.addEventListener(type,listener,options),this.eventListenersLog.push({name:type,hook:listener})}observeUnsolicitedPayload(observer,payloadIdSupplier){this.observeEventSource((payload=>{observer(payload,this)}),payloadIdSupplier),this.observeWebSocketReceiveEvent((payload=>{observer(payload,this)}),payloadIdSupplier)}observeReceivedPayload(observer,payloadIdSupplier){this.observeEventSource((payload=>{observer(payload,this)}),payloadIdSupplier),this.observeWebSocketReceiveEvent((payload=>{observer(payload,this)}),payloadIdSupplier),this.observeFetchEventResponse(((_fetched,received)=>{observer(received,this)}),payloadIdSupplier)}observeSolicitedPayload(observer,payloadIdSupplier){this.observeFetchEventResponse(((payload,responsePayload,ctx)=>{observer(payload,responsePayload,ctx,this)}),payloadIdSupplier)}fetch(uase,suggestedCtx){const ctx={...suggestedCtx,transactionID:"TODO:UUIDv5?",clientProvenance:"ServiceBus.fetch"},fetchPayload=uase.prepareFetchPayload(ctx,this),fetchInit=uase.prepareFetch(this.args.fetchBaseURL,fetchPayload,ctx,this),fetchDetail={...fetchInit,fetchPayload:fetchPayload,context:ctx,fetchStrategy:this};this.dispatchNamingStrategyEvent(fetchPayload,this.args.eventNameStrategy.fetch,fetchDetail),fetch(fetchInit.endpoint,fetchInit.requestInit).then((resp=>{if(resp.ok)resp.json().then((fetchRespRawJSON=>{const fetchRespPayload=uase.prepareFetchResponsePayload(fetchPayload,fetchRespRawJSON,ctx,this),fetchRespDetail={fetchPayload:fetchPayload,fetchRespPayload:fetchRespPayload,context:ctx,fetchStrategy:this};this.dispatchNamingStrategyEvent(fetchPayload,this.args.eventNameStrategy.fetchResponse,fetchRespDetail)}));else{const fetchErrorDetail={...fetchInit,fetchPayload:fetchPayload,context:ctx,error:new Error(`${fetchInit.endpoint} invalid HTTP status ${resp.status} (${resp.statusText})`),fetchStrategy:this};this.dispatchNamingStrategyEvent(fetchPayload,this.args.eventNameStrategy.fetchError,fetchErrorDetail)}})).catch((error=>{const fetchErrorDetail={...fetchInit,fetchPayload:fetchPayload,context:ctx,error:error,fetchStrategy:this};this.dispatchNamingStrategyEvent(fetchPayload,this.args.eventNameStrategy.fetchError,fetchErrorDetail),console.error(`${fetchInit.endpoint} POST error`,error,fetchInit)}))}observeFetchEvent(observer,payloadIdSupplier){const payloadID=payloadIdSupplier?"string"==typeof payloadIdSupplier?payloadIdSupplier:payloadIdSupplier.payloadIdentity:this.args.eventNameStrategy.universalScopeID,names=this.args.eventNameStrategy.fetch(payloadID);this.addEventListener(names.selectedName,(event=>{const typedCustomEvent=event,{fetchPayload:fetchPayload,requestInit:requestInit,context:context,fetchStrategy:fetchStrategy}=typedCustomEvent.detail;observer(fetchPayload,requestInit,context,fetchStrategy)}))}observeFetchEventResponse(observer,payloadIdSupplier){const payloadID=payloadIdSupplier?"string"==typeof payloadIdSupplier?payloadIdSupplier:payloadIdSupplier.payloadIdentity:this.args.eventNameStrategy.universalScopeID,names=this.args.eventNameStrategy.fetchResponse(payloadID);this.addEventListener(names.selectedName,(event=>{const typedCustomEvent=event,{fetchPayload:fetchPayload,fetchRespPayload:fetchRespPayload,context:context,fetchStrategy:fetchStrategy}=typedCustomEvent.detail;observer(fetchRespPayload,fetchPayload,context,fetchStrategy)}))}observeFetchEventError(observer,payloadIdSupplier){const payloadID=payloadIdSupplier?"string"==typeof payloadIdSupplier?payloadIdSupplier:payloadIdSupplier.payloadIdentity:this.args.eventNameStrategy.universalScopeID,names=this.args.eventNameStrategy.fetchError(payloadID);this.addEventListener(names.selectedName,(event=>{const typedCustomEvent=event,{fetchPayload:fetchPayload,error:error,requestInit:requestInit,context:context,fetchStrategy:fetchStrategy}=typedCustomEvent.detail;observer(error,requestInit,fetchPayload,context,fetchStrategy)}))}observeEventSource(observer,payloadIdSupplier){const payloadID=payloadIdSupplier?"string"==typeof payloadIdSupplier?payloadIdSupplier:payloadIdSupplier.payloadIdentity:this.args.eventNameStrategy.universalScopeID,names=this.args.eventNameStrategy.eventSource(payloadID);this.addEventListener(names.selectedName,(event=>{const typedCustomEvent=event;let{eventSrcPayload:eventSrcPayload}=typedCustomEvent.detail;isEventSourceService(payloadIdSupplier)&&payloadIdSupplier.isEventSourcePayload(eventSrcPayload)&&(eventSrcPayload=payloadIdSupplier.prepareEventSourcePayload(eventSrcPayload),eventSrcPayload.isValidatedPayload=!0),observer(eventSrcPayload,this)}))}observeEventSourceError(observer,payloadIdSupplier){const payloadID=payloadIdSupplier?"string"==typeof payloadIdSupplier?payloadIdSupplier:payloadIdSupplier.payloadIdentity:this.args.eventNameStrategy.universalScopeID,names=this.args.eventNameStrategy.eventSourceError(payloadID);this.addEventListener(names.selectedName,(event=>{const typedCustomEvent=event,{eventSrcPayload:eventSrcPayload,error:error}=typedCustomEvent.detail;observer(error,eventSrcPayload,this)}))}webSocketSend(context,wss){for(const ws of this.wsTunnels)ws.activeSocket?.send(wss.prepareWebSocketSend(wss.prepareWebSocketSendPayload(context,this),this))}prepareWebSocketReceivePayload(webSocketReceiveRaw){if("string"!=typeof webSocketReceiveRaw)throw Error("webSocketReceiveRaw must be text; TODO: allow binary?");return JSON.parse(webSocketReceiveRaw)}observeWebSocketSendEvent(observer,payloadIdSupplier){const payloadID=payloadIdSupplier?"string"==typeof payloadIdSupplier?payloadIdSupplier:payloadIdSupplier.payloadIdentity:this.args.eventNameStrategy.universalScopeID,names=this.args.eventNameStrategy.webSocket(payloadID);this.addEventListener(names.selectedName,(event=>{const typedCustomEvent=event,{context:context,payload:payload,webSocketStrategy:webSocketStrategy}=typedCustomEvent.detail;observer(payload,context,webSocketStrategy)}))}observeWebSocketReceiveEvent(observer,payloadIdSupplier){const payloadID=payloadIdSupplier?"string"==typeof payloadIdSupplier?payloadIdSupplier:payloadIdSupplier.payloadIdentity:this.args.eventNameStrategy.universalScopeID,names=this.args.eventNameStrategy.webSocket(payloadID);this.addEventListener(names.selectedName,(event=>{const typedCustomEvent=event;let{payload:payload}=typedCustomEvent.detail;isEventSourceService(payloadIdSupplier)&&payloadIdSupplier.isEventSourcePayload(payload)&&(payload=payloadIdSupplier.prepareEventSourcePayload(payload),payload.isValidatedPayload=!0),observer(payload,this)}))}observeWebSocketErrorEvent(observer,payloadIdSupplier){const payloadID=payloadIdSupplier?"string"==typeof payloadIdSupplier?payloadIdSupplier:payloadIdSupplier.payloadIdentity:this.args.eventNameStrategy.universalScopeID,names=this.args.eventNameStrategy.webSocketError(payloadID);this.addEventListener(names.selectedName,(event=>{const typedCustomEvent=event,{error:error}=typedCustomEvent.detail;observer(error,void 0,this)}))}args}export{serviceBusArguments};export{ServiceBus};const isWebSocketConnectionHealthy=typeGuard("isHealthy","connEstablishedOn"),isWebSocketConnectionUnhealthy=typeGuard("isHealthy","connFailedOn"),isWebSocketReconnecting=typeGuard("isHealthy","connFailedOn","reconnectStrategy"),isWebSocketErrorEventSupplier=typeGuard("isEventSourceError","errorEvent"),isWebSocketCloseEventSupplier=typeGuard("isCloseEvent","closeEvent"),isWebSocketEndpointUnavailable=typeGuard("isEndpointUnavailable","endpointURL");class WebSocketTunnel{wsURL;wsEndpointValidator;observerUniversalScopeID="universal";webSocketFactory;onConnStateChange;onReconnStateChange;allowClose;#activeSocket;#connectionState={isConnectionState:!0};#reconnStrategy;constructor(init){this.wsURL=init.wsURL,this.wsEndpointValidator=init.wsEndpointValidator,this.webSocketFactory=init.webSocketFactory,this.onConnStateChange=init.options?.onConnStateChange,this.onReconnStateChange=init.options?.onReconnStateChange,this.allowClose=init.options?.allowClose}isReconnecting(){return!!this.#reconnStrategy&&this.#reconnStrategy}isReconnectAborted(){return!(!this.#reconnStrategy||!this.#reconnStrategy.isAborted)}connected(ws,connState){this.#reconnStrategy&&this.#reconnStrategy.completed(),this.webSocketFactory.connected?.(ws),this.connectionState=connState,this.#reconnStrategy=void 0}prepareReconnect(connState){return this.#reconnStrategy=this.#reconnStrategy??new ReconnectionStrategy({onStateChange:this.onReconnStateChange?(active,previous,rs)=>{this.onReconnStateChange?.(active,previous,rs,this)}:void 0}),connState={...connState,reconnectStrategy:this.#reconnStrategy},this.connectionState=connState,this.#reconnStrategy.reconnect()}init(){if(!this.isReconnectAborted())return this.wsEndpointValidator.validate(this.#reconnStrategy).then((resp=>{if(resp.ok){this.#activeSocket&&this.#activeSocket.close(),this.#activeSocket=void 0;const ws=this.#activeSocket=this.webSocketFactory.construct(this.wsURL);ws.onopen=()=>{this.connected(ws,{isConnectionState:!0,isHealthy:!0,connEstablishedOn:new Date,endpointURL:this.wsURL,pingURL:this.wsEndpointValidator.validationEndpointURL.toString()})},ws.onclose=event=>{if(!(this.allowClose?.(event,this)??!1)){const connState={isConnectionState:!0,isHealthy:!1,connFailedOn:new Date,isCloseEvent:!0,closeEvent:event},reconnectStrategy=this.prepareReconnect(connState);setTimeout((()=>this.init()),reconnectStrategy.intervalMillecs)}},ws.onerror=event=>{ws.close();const connState={isConnectionState:!0,isHealthy:!1,connFailedOn:new Date,isEventSourceError:!0,errorEvent:event},reconnectStrategy=this.prepareReconnect(connState);setTimeout((()=>this.init()),reconnectStrategy.intervalMillecs)}}else{const connState={isConnectionState:!0,isHealthy:!1,connFailedOn:new Date,isEndpointUnavailable:!0,endpointURL:this.wsURL,pingURL:this.wsEndpointValidator.validationEndpointURL.toString(),httpStatus:resp.status,httpStatusText:resp.statusText},reconnectStrategy=this.prepareReconnect(connState);setTimeout((()=>this.init()),reconnectStrategy.intervalMillecs)}})).catch((connectionError=>{const connState={isConnectionState:!0,isHealthy:!1,connFailedOn:new Date,pingURL:this.wsEndpointValidator.validationEndpointURL.toString(),connectionError:connectionError,isEndpointUnavailable:!0,endpointURL:this.wsURL},reconnectStrategy=this.prepareReconnect(connState);setTimeout((()=>this.init()),reconnectStrategy.intervalMillecs)})),this}get activeSocket(){return this.#activeSocket}get connectionState(){return this.#connectionState}set connectionState(value){const previousConnState=this.#connectionState;this.#connectionState=value,this.onConnStateChange?.(this.#connectionState,previousConnState,this)}}function webSocketConnNarrative(tunnel,reconn){const ws=tunnel.connectionState;!reconn&&isWebSocketReconnecting(ws)&&(reconn=ws.reconnectStrategy);let reconnected=!1;if(reconn)switch(reconn.state){case ReconnectionState.TRYING:return{summary:`reconnecting ${reconn.attempt}/${reconn.maxAttempts}`,color:"orange",isHealthy:!1,summaryHint:`Trying to reconnect to ${tunnel.wsURL} (WS), reconnecting every ${reconn.intervalMillecs} milliseconds`};case ReconnectionState.ABORTED:return{summary:"failed",color:"red",isHealthy:!1,summaryHint:`Unable to reconnect to ${tunnel.wsURL} (WS) after ${reconn.maxAttempts} attempts, giving up`};case ReconnectionState.COMPLETED:reconnected=!0}if(isWebSocketConnectionHealthy(ws))return{summary:reconnected?"reconnected":"connected",color:"green",isHealthy:!0,summaryHint:`Connection to ${ws.endpointURL} (WS) verified using ${ws.pingURL} on ${ws.connEstablishedOn}`};let summary="unknown",color="purple",summaryHint="the WebSocket tunnel is not healthy, but not sure why";return isWebSocketConnectionUnhealthy(ws)&&(isWebSocketEndpointUnavailable(ws)?(summary="WS unavailable",summaryHint=`${ws.endpointURL} not available`,ws.httpStatus&&(summary=`WS unavailable (${ws.httpStatus})`,summaryHint+=` (HTTP status: ${ws.httpStatus}, ${ws.httpStatusText})`,color="red")):isWebSocketErrorEventSupplier(ws)&&(summary="error",summaryHint=JSON.stringify(ws.errorEvent),color="red")),{isHealthy:!1,summary:summary,summaryHint:summaryHint,color:color}}export{isWebSocketConnectionHealthy};export{isWebSocketConnectionUnhealthy};export{isWebSocketReconnecting};export{isWebSocketErrorEventSupplier};export{isWebSocketCloseEventSupplier};export{isWebSocketEndpointUnavailable};export{WebSocketTunnel};export{webSocketConnNarrative};function markdownItTransformer(){return{dependencies:void 0,acquireDependencies:async transformer=>{const{default:markdownIt}=await import("https://jspm.dev/markdown-it@12.2.0");return{markdownIt:markdownIt,plugins:await transformer.plugins()}},construct:async transformer=>{transformer.dependencies||(transformer.dependencies=await transformer.acquireDependencies(transformer));const markdownIt=transformer.dependencies.markdownIt({html:!0,linkify:!0,typographer:!0});return transformer.customize(markdownIt,transformer),markdownIt},customize:(markdownIt,transformer)=>{const plugins=transformer.dependencies.plugins;return markdownIt.use(plugins.footnote),transformer},unindentWhitespace:(text,removeInitialNewLine=!0)=>{const whitespace=text.match(/^[ \t]*(?=\S)/gm),indentCount=whitespace?whitespace.reduce(((r,a)=>Math.min(r,a.length)),1/0):0,regex=new RegExp(`^[ \\t]{${indentCount}}`,"gm"),result=text.replace(regex,"");return removeInitialNewLine?result.replace(/^\n/,""):result},plugins:async()=>{const{default:footnote}=await import("https://jspm.dev/markdown-it-footnote@3.0.3");return{footnote:footnote,adjustHeadingLevel:(md,options)=>{function getHeadingLevel(tagName){return"h"===tagName[0].toLowerCase()&&(tagName=tagName.slice(1)),parseInt(tagName,10)}const firstLevel=options.firstLevel;if("string"==typeof firstLevel&&(firstLevel=getHeadingLevel(firstLevel)),!firstLevel||isNaN(firstLevel))return;const levelOffset=firstLevel-1;levelOffset<1||levelOffset>6||md.core.ruler.push("adjust-heading-levels",(function(state){const tokens=state.tokens;for(let i=0;i<tokens.length;i++){if("heading_close"!==tokens[i].type)continue;const headingOpen=tokens[i-2],headingClose=tokens[i],currentLevel=getHeadingLevel(headingOpen.tag),tagName="h"+Math.min(currentLevel+levelOffset,6);headingOpen.tag=tagName,headingClose.tag=tagName}}))}}}}}async function renderMarkdown(strategies,mditt=markdownItTransformer()){const markdownIt=await mditt.construct(mditt);for await(const strategy of strategies(mditt)){const markdown=mditt.unindentWhitespace(await strategy.markdownText(mditt));strategy.renderHTML(markdownIt.render(markdown),mditt)}}function importMarkdownContent(input,select,inject){fetch(input).then((resp=>{resp.text().then((html=>{const foreignDoc=(new DOMParser).parseFromString(html,"text/html"),selected=select(foreignDoc);if(Array.isArray(selected))for(const s of selected){const importedNode=document.adoptNode(s);inject(importedNode,input,html)}else if(selected){const importedNode1=document.adoptNode(selected);inject(importedNode1,input,html)}}))}))}async function transformMarkdownElemsCustom(srcElems,finalizeElemFn,mditt=markdownItTransformer()){await renderMarkdown((function*(){for(const elem of srcElems)yield{markdownText:async()=>{if(elem.dataset.transformableSrc){const response=await fetch(elem.dataset.transformableSrc);return response.ok?await response.text():`Error fetching ${elem.dataset.transformableSrc}: ${response.status}`}return elem.innerText},renderHTML:async html=>{try{const formatted=document.createElement("div");formatted.innerHTML=html,elem.parentElement.replaceChild(formatted,elem),finalizeElemFn&&finalizeElemFn(formatted,elem)}catch(error){console.error("Undiagnosable error in renderHTML()",error)}}}}),mditt)}async function transformMarkdownElems(firstHeadingLevel=2){const mdittDefaults=markdownItTransformer();await transformMarkdownElemsCustom(document.querySelectorAll('[data-transformable="markdown"]'),((mdHtmlElem,mdSrcElem)=>{mdHtmlElem.dataset.transformedFrom="markdown",mdSrcElem.className&&(mdHtmlElem.className=mdSrcElem.className),document.dispatchEvent(new CustomEvent("transformed-markdown",{detail:{mdHtmlElem:mdHtmlElem,mdSrcElem:mdSrcElem}}))}),{...mdittDefaults,customize:(markdownIt,transformer)=>{mdittDefaults.customize(markdownIt,transformer),markdownIt.use(transformer.dependencies.plugins.adjustHeadingLevel,{firstLevel:firstHeadingLevel})}})}export{markdownItTransformer};export{renderMarkdown};export{importMarkdownContent};export{transformMarkdownElemsCustom};export{transformMarkdownElems};