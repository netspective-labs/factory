export interface RdbmsColumnDefn {
  readonly tableName: string;
  readonly columnName: string;
  readonly columnDataType: string;
  readonly isRequired: boolean;
  readonly isPrimaryKey: boolean;
  readonly defaultValue: unknown;
}

export interface RdbmsDataTypeMapEntry {
  readonly tsType: string;
  readonly declare?: string;
}

export interface RdbmsDialect {
  readonly identity: string;
  readonly sqlDataTypeToTsType: (sqlDataType: string) => RdbmsDataTypeMapEntry;
  readonly tsTypes: () => ArrayLike<RdbmsDataTypeMapEntry>;
  readonly typescriptHeader: () => string[];
  readonly tableNameStrategy: (tableName: string) => string;
  readonly colNameStrategy: (colName: string) => string;
}

export const snakeToCamelCase = (str: string) =>
  str.replace(/([-_]\w)/g, (g) => g[1].toUpperCase());

export const snakeToPascalCase = (str: string) => {
  const camelCase = snakeToCamelCase(str);
  return camelCase[0].toUpperCase() + camelCase.substring(1);
};

export const typicalTypescriptHeader: string[] = [
  "// generated by rdbms-schema-ts.ts. DO NOT EDIT.",
  "",
  "export type CamelCase<S extends string> = S extends",
  "  `${infer P1}_${infer P2}${infer P3}`",
  "  ? `${Lowercase<P1>}${Uppercase<P2>}${CamelCase<P3>}`",
  "  : Lowercase<S>;",
  "export type TableToObject<T> = {",
  "  [K in keyof T as CamelCase<string & K>]: T[K] extends Date ? T[K]",
  "    : // deno-lint-ignore ban-types",
  "    (T[K] extends object ? TableToObject<T[K]> : T[K]);",
  "};",
];

export function rdbmsSchemaToTypescript(
  columnDefns: () => Generator<RdbmsColumnDefn>,
  dialect: RdbmsDialect,
): string {
  const tables = new Map<string, RdbmsColumnDefn[]>();
  for (const colDefn of columnDefns()) {
    const tableName = colDefn.tableName.toLowerCase();
    if (tableName == "sqlite_sequence") continue;

    let table = tables.get(tableName);
    if (!table) {
      table = [];
      tables.set(tableName, table);
    }
    table.push({
      ...colDefn,
      tableName,
      columnName: colDefn.columnName.toLowerCase(),
    });
  }

  const { tableNameStrategy: tns, colNameStrategy: cns } = dialect;
  const tsBody: string[] = [];
  for (const table of tables.entries()) {
    const [name, columns] = table;
    const pkColumns = [];
    const defaultedColumns = [];
    tsBody.push(`export interface mutable_${name} {`);
    for (const column of columns) {
      const tsType = dialect.sqlDataTypeToTsType(
        column.columnDataType.toUpperCase(),
      );
      const remarks = [];
      const required = (column.isRequired || column.isPrimaryKey) &&
        (!column.defaultValue);
      if (column.isPrimaryKey) {
        remarks.push("primary key");
        pkColumns.push(column);
      }
      if (column.defaultValue) {
        remarks.push(`default value: ${column.defaultValue}`);
        defaultedColumns.push(column);
      }
      tsBody.push(
        `  ${column.columnName}${required ? "" : "?"}: ${
          tsType.tsType || `unknown`
        }${remarks.length > 0 ? `// ${remarks.join(", ")}` : ""}`,
      );
    }
    const omitInsertables = [...pkColumns, ...defaultedColumns];
    const omitUpdatables = omitInsertables;
    tsBody.push(`}\n`);
    tsBody.push(
      `export const ${tns(name)}TableName = "${name}";`,
      `export type ${name} = Readonly<mutable_${name}>;`,
      `export type Mutable${tns(name)} = TableToObject<mutable_${name}>;`,
      `export type ${tns(name)} = Readonly<Mutable${tns(name)}>;`,
      // deno-fmt-ignore
      `export type ${name}_insertable = Omit<${name}, ${omitInsertables.map(c => `"${c.columnName}"`).join(" | ")}> & Partial<Pick<${name}, ${defaultedColumns.map(c => `"${c.columnName}"`).join(" | ")}>>;`,
      // deno-fmt-ignore
      `export type mutable_${name}_insertable = Omit<mutable_${name}, ${omitInsertables.map(c => `"${c.columnName}"`).join(" | ")}> & Partial<Pick<mutable_${name}, ${defaultedColumns.map(c => `"${c.columnName}"`).join(" | ")}>>;`,
      // deno-fmt-ignore
      `export type ${tns(name)}Insertable = Omit<${tns(name)}, ${omitInsertables.map(c => `"${cns(c.columnName)}"`).join(" | ")}> & Partial<Pick<${tns(name)}, ${defaultedColumns.map(c => `"${cns(c.columnName)}"`).join(" | ")}>>;`,
      // deno-fmt-ignore
      `export type ${name}_updateable = Omit<${name}, ${omitUpdatables.map(c => `"${c.columnName}"`).join(" | ")}> & Partial<Pick<${name}, ${defaultedColumns.map(c => `"${c.columnName}"`).join(" | ")}>>;`,
      // deno-fmt-ignore
      `export type ${tns(name)}Updatable = Omit<${tns(name)}, ${omitUpdatables.map(c => `"${cns(c.columnName)}"`).join(" | ")}> & Partial<Pick<${tns(name)}, ${defaultedColumns.map(c => `"${cns(c.columnName)}"`).join(" | ")}>>;\n\n`,
    );
    // deno-fmt-ignore
    tsBody.push(`export const transform${tns(name)} = {
        tableName: "${name}",
        fromTable: (t: ${name}): ${tns(name)} => ({
          ${columns.map(c => `    ${cns(c.columnName)}: t.${c.columnName}`).join(",\n")}
        }),
        toTable: (o: ${tns(name)}): ${name} => ({
          ${columns.map(c => `    ${c.columnName}: o.${cns(c.columnName)}`).join(",\n")}
        }),
        insertable: (o: ${tns(name)}Insertable): ${name}_insertable => {
          const insertable: mutable_${name}_insertable = {
            ${columns.filter(c => omitInsertables.find(o => o.columnName == c.columnName && !c.defaultValue) ? false : true).map(c => `    ${c.columnName}: o.${cns(c.columnName)}`).join(",\n")}
          };
          ${defaultedColumns.map(dc => `if(typeof insertable.${dc.columnName} === "undefined") delete insertable.${dc.columnName}; // allow RDBMS to supply the defaultValue ${dc.defaultValue}`).join("\n")}
          return insertable;
        },
      };\n`);
  }

  return [...dialect.typescriptHeader(), ...tsBody].join("\n");
}
